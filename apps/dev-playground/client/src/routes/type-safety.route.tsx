import { createFileRoute, retainSearchParams } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { codeToHtml } from "shiki";
import { Header } from "@/components/layout/header";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

export const Route = createFileRoute("/type-safety")({
  component: TypeSafetyRoute,
  search: {
    middlewares: [retainSearchParams(true)],
  },
});

function CodeBlock({
  code,
  lang = "typescript",
}: {
  code: string;
  lang?: string;
}) {
  const [html, setHtml] = useState("");

  useEffect(() => {
    codeToHtml(code, {
      lang,
      theme: "dark-plus",
    }).then(setHtml);
  }, [code, lang]);

  if (!html) {
    return (
      <pre className="bg-gray-800 text-gray-300 p-4 rounded-md text-sm font-mono overflow-x-auto">
        {code}
      </pre>
    );
  }

  return (
    <div
      className="rounded-md overflow-hidden [&>pre]:m-0 [&>pre]:p-4 [&>pre]:text-sm"
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
}

const SQL_FILE_EXAMPLE = `-- @param groupBy STRING
-- @param aggregationLevel STRING
-- @param startDate DATE
-- @param endDate DATE

SELECT
  COALESCE(:groupBy, 'default') as group_key,
  date_trunc(:aggregationLevel, usage_date) AS period,
  SUM(usage_quantity * pricing) AS cost_usd
FROM system.billing.usage
WHERE usage_date BETWEEN :startDate AND :endDate
GROUP BY period
ORDER BY period DESC`;

const GENERATED_TYPES = `// Auto-generated by AppKit - DO NOT EDIT
import "@databricks/app-kit-ui/react";
import type { SQLStringMarker, SQLDateMarker } from "@databricks/app-kit-ui/js";

declare module "@databricks/app-kit-ui/react" {
  interface QueryRegistry {
    spend_data: {
      name: "spend_data";
      parameters: {
        /** STRING - use sql.string() */
        groupBy: SQLStringMarker;
        /** DATE - use sql.date() */
        startDate: SQLDateMarker;
        /** DATE - use sql.date() */
        endDate: SQLDateMarker;
      };
      result: Array<{
        /** @sqlType STRING */
        group_key: string;
        /** @sqlType TIMESTAMP */
        period: string;
        /** @sqlType DECIMAL */
        cost_usd: number;
      }>;
    };
  }
}`;

const USAGE_EXAMPLE = `import { sql } from "@databricks/app-kit-ui/js";
import { useAnalyticsQuery } from "@databricks/app-kit-ui/react";

function SpendChart() {
  const { data, loading, error } = useAnalyticsQuery("spend_data", {
    groupBy: sql.string("app_name"),
    startDate: sql.date("2024-01-01"),
    endDate: sql.date("2024-12-31"),
  });

  // data is typed as Array<{
  //   group_key: string;
  //   period: string;
  //   cost_usd: number;
  // }>

  return data?.map(row => (
    <div key={row.period}>
      {row.group_key}: \${row.cost_usd.toFixed(2)}
    </div>
  ));
}`;

function FlowStep({
  number,
  title,
  active,
}: {
  number: number;
  title: string;
  active: boolean;
}) {
  return (
    <div className="flex items-center">
      <div className="flex flex-col items-center">
        <div
          className={`w-10 h-10 rounded-full flex items-center justify-center text-white font-semibold text-sm ${
            active ? "bg-gray-900" : "bg-gray-400"
          }`}
        >
          {number}
        </div>
        <span
          className={`mt-2 text-xs ${active ? "text-gray-900 font-medium" : "text-gray-500"}`}
        >
          {title}
        </span>
      </div>
    </div>
  );
}

function FlowDiagram() {
  const [activeStep, setActiveStep] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setActiveStep((prev) => (prev + 1) % 3);
    }, 2000);
    return () => clearInterval(interval);
  }, []);

  const steps = ["SQL File", "Generated Types", "IntelliSense"];

  return (
    <div className="flex items-center justify-center gap-6 py-4">
      {steps.map((step, index) => (
        <div key={step} className="flex items-center">
          <FlowStep
            number={index + 1}
            title={step}
            active={index <= activeStep}
          />
          {index < steps.length - 1 && (
            <div
              className={`w-8 h-0.5 mx-3 ${index < activeStep ? "bg-gray-900" : "bg-gray-300"}`}
            />
          )}
        </div>
      ))}
    </div>
  );
}

function IntelliSenseDemo() {
  const [step, setStep] = useState(0);
  const [showAutocomplete, setShowAutocomplete] = useState(false);
  const [showParamHint, setShowParamHint] = useState(false);
  const [showResultHint, setShowResultHint] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [timeoutIds, setTimeoutIds] = useState<ReturnType<typeof setTimeout>[]>(
    [],
  );

  const queryNames = [
    "apps_list",
    "cost_recommendations",
    "spend_data",
    "spend_summary",
  ];

  const clearAllTimeouts = () => {
    for (const id of timeoutIds) {
      clearTimeout(id);
    }
    setTimeoutIds([]);
  };

  const scheduleFromStep = (fromStep: number) => {
    const ids: ReturnType<typeof setTimeout>[] = [];
    let delay = 0;

    // Step 1: Show autocomplete (500ms)
    if (fromStep < 1) {
      delay += 500;
      ids.push(
        setTimeout(() => {
          setStep(1);
          setShowAutocomplete(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before next
    }

    // Step 2: Hide autocomplete, select query (after autocomplete shown)
    if (fromStep < 2) {
      if (fromStep >= 1) delay += 2000; // If resuming from step 1
      ids.push(
        setTimeout(() => {
          setStep(2);
          setShowAutocomplete(false);
        }, delay),
      );
      delay += 500; // Wait 500ms before showing params
    }

    // Show param hints
    if (fromStep < 2 || (fromStep === 2 && !showParamHint)) {
      if (fromStep === 2) delay += 500; // If resuming from step 2
      ids.push(
        setTimeout(() => {
          setShowParamHint(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before next
    }

    // Step 3: Hide param hints, fill in params
    if (fromStep < 3) {
      if (fromStep === 2 && showParamHint) delay += 2000; // If resuming with params shown
      ids.push(
        setTimeout(() => {
          setStep(3);
          setShowParamHint(false);
        }, delay),
      );
      delay += 500; // Wait 500ms before showing results
    }

    // Show result hints
    if (fromStep < 3 || (fromStep === 3 && !showResultHint)) {
      if (fromStep === 3) delay += 500; // If resuming from step 3
      ids.push(
        setTimeout(() => {
          setShowResultHint(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before complete
    }

    // Step 4: Complete
    if (fromStep < 4) {
      if (fromStep === 3 && showResultHint) delay += 2000; // If resuming with results shown
      ids.push(
        setTimeout(() => {
          setStep(4);
        }, delay),
      );
    }

    setTimeoutIds(ids);
  };

  const togglePause = () => {
    if (isPaused) {
      // Resume from current step
      setIsPaused(false);
      scheduleFromStep(step);
    } else {
      // Pause
      clearAllTimeouts();
      setIsPaused(true);
    }
  };

  const runDemo = () => {
    clearAllTimeouts();
    setIsPaused(false);
    setStep(0);
    setShowAutocomplete(false);
    setShowParamHint(false);
    setShowResultHint(false);

    scheduleFromStep(0);
  };

  const codeLines = [
    "const { data } = useAnalyticsQuery(",
    step >= 2 ? '  "spend_data",' : '  "|"',
    "  {",
    step >= 3
      ? '    startDate: sql.date("2024-01-01"),'
      : step >= 2
        ? "    |"
        : "",
    step >= 3 ? '    endDate: sql.date("2024-12-31"),' : "",
    "  }",
    ");",
    "",
    step >= 3 ? "data?.map(row => row.|)" : "",
  ].filter(Boolean);

  return (
    <div>
      <div className="relative bg-gray-800 rounded-md p-4 font-mono text-sm min-h-[240px]">
        <pre className="text-gray-300">
          {codeLines.map((line) => (
            <div key={line} className="leading-6">
              {line.includes("|") ? (
                <>
                  {line.split("|")[0]}
                  <span className="bg-white text-gray-900 animate-pulse">
                    |
                  </span>
                  {line.split("|")[1]}
                </>
              ) : (
                <span
                  className={
                    line.includes('"spend_data"')
                      ? "text-green-400"
                      : line.includes("sql.")
                        ? "text-green-400"
                        : ""
                  }
                >
                  {line}
                </span>
              )}
            </div>
          ))}
        </pre>

        {showAutocomplete && (
          <div className="absolute left-20 top-10 bg-[#252526] border border-gray-600 rounded shadow-lg z-10 w-56">
            <div className="text-xs text-gray-400 px-2 py-1 border-b border-gray-600">
              QueryRegistry
            </div>
            {queryNames.map((name, i) => (
              <div
                key={name}
                className={`px-3 py-1 text-sm font-mono ${
                  i === 2 ? "bg-gray-700 text-white" : "text-gray-300"
                }`}
              >
                {name}
              </div>
            ))}
          </div>
        )}

        {showParamHint && (
          <div className="absolute left-24 top-16 bg-[#252526] border border-gray-600 rounded shadow-lg z-10 w-60">
            <div className="text-xs text-gray-400 px-2 py-1 border-b border-gray-600">
              Parameters (spend_data)
            </div>
            <div className="p-2 text-sm font-mono text-gray-300">
              <div>groupBy: SQLStringMarker</div>
              <div>startDate: SQLDateMarker</div>
              <div>endDate: SQLDateMarker</div>
            </div>
          </div>
        )}

        {showResultHint && (
          <div className="absolute left-56 bottom-10 bg-[#252526] border border-gray-600 rounded shadow-lg z-10 w-48">
            <div className="text-xs text-gray-400 px-2 py-1 border-b border-gray-600">
              Result Fields
            </div>
            {["group_key: string", "period: string", "cost_usd: number"].map(
              (field, i) => (
                <div
                  key={field}
                  className={`px-3 py-1 text-sm font-mono ${
                    i === 2 ? "bg-gray-700 text-white" : "text-gray-300"
                  }`}
                >
                  {field}
                </div>
              ),
            )}
          </div>
        )}
      </div>

      <div className="flex items-center gap-4 mt-4">
        <Button variant="outline" size="sm" onClick={runDemo}>
          Run Demo
        </Button>
        {step > 0 && step < 4 && (
          <Button variant="outline" size="sm" onClick={togglePause}>
            {isPaused ? "Resume" : "Pause"}
          </Button>
        )}
        <span className="text-sm text-gray-500">
          {isPaused && "(Paused) "}
          {step === 0 && "Click to start"}
          {step === 1 && "Query name autocomplete"}
          {step === 2 && "Parameter hints"}
          {step === 3 && "Result field suggestions"}
          {step === 4 && "Complete!"}
        </span>
      </div>
    </div>
  );
}

function TypeSafetyRoute() {
  return (
    <div className="min-h-[calc(100vh-73px)] bg-gray-50">
      <div className="max-w-[1200px] mx-auto px-6 py-12">
        <Header
          title="Type-Safe SQL Queries"
          description="Generate TypeScript types from SQL files at build time with full IntelliSense support."
          tooltip="Demonstrates automatic type generation from SQL files using Vite plugin or npx command"
        />

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Flow Diagram */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>How It Works</CardTitle>
              <CardDescription>
                SQL files with @param annotations are processed to generate
                TypeScript types
              </CardDescription>
            </CardHeader>
            <CardContent>
              <FlowDiagram />
            </CardContent>
          </Card>

          {/* SQL File */}
          <Card>
            <CardHeader>
              <CardTitle>1. SQL File</CardTitle>
              <CardDescription>
                Write SQL queries with @param annotations to define parameter
                types
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={SQL_FILE_EXAMPLE} lang="sql" />
            </CardContent>
          </Card>

          {/* Generated Types */}
          <Card>
            <CardHeader>
              <CardTitle>2. Generated Types</CardTitle>
              <CardDescription>
                Vite plugin or npx command generates appKitTypes.d.ts at build
                time
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={GENERATED_TYPES} lang="typescript" />
            </CardContent>
          </Card>

          {/* IntelliSense Demo */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>3. IntelliSense</CardTitle>
              <CardDescription>
                Your IDE provides full autocomplete for query names, parameters,
                and results
              </CardDescription>
            </CardHeader>
            <CardContent>
              <IntelliSenseDemo />
            </CardContent>
          </Card>

          {/* Usage Example */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>Usage Example</CardTitle>
              <CardDescription>
                Type-safe queries in your React components
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={USAGE_EXAMPLE} lang="typescript" />
            </CardContent>
          </Card>

          {/* Vite Plugin */}
          <Card>
            <CardHeader>
              <CardTitle>Vite Plugin</CardTitle>
              <CardDescription>
                Automatic type generation during development
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock
                code={`// vite.config.ts
import { appKitTypesPlugin } from '@databricks/app-kit';

export default defineConfig({
  plugins: [
    appKitTypesPlugin(),
    // Optional: appKitTypesPlugin({
    //   outputFile: 'src/appKitTypes.d.ts',
    //   watchFolders: ['../config/queries'],
    // }),
  ],
});`}
              />
            </CardContent>
          </Card>

          {/* NPX Command */}
          <Card>
            <CardHeader>
              <CardTitle>NPX Command</CardTitle>
              <CardDescription>Manual or CI/CD type generation</CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock
                code={`# Generate types from project root
npx appkit-generate-types

# Custom output path
npx appkit-generate-types . client/src/types.d.ts

# Force regeneration (skip cache)
npx appkit-generate-types --no-cache`}
                lang="bash"
              />
            </CardContent>
          </Card>

          {/* Supported Types */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>Supported Parameter Types</CardTitle>
              <CardDescription>
                Use @param annotations in SQL files to define typed parameters
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                {[
                  { annotation: "@param name STRING", helper: "sql.string()" },
                  {
                    annotation: "@param count NUMERIC",
                    helper: "sql.number()",
                  },
                  {
                    annotation: "@param active BOOLEAN",
                    helper: "sql.boolean()",
                  },
                  { annotation: "@param start DATE", helper: "sql.date()" },
                  {
                    annotation: "@param created TIMESTAMP",
                    helper: "sql.timestamp()",
                  },
                  { annotation: "@param data BINARY", helper: "sql.binary()" },
                ].map((type) => (
                  <div
                    key={type.annotation}
                    className="p-3 bg-gray-100 rounded"
                  >
                    <code className="text-xs text-gray-600 block">
                      -- {type.annotation}
                    </code>
                    <code className="text-sm text-gray-900 font-medium">
                      {type.helper}
                    </code>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
