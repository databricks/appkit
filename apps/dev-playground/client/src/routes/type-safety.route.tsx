import {
  Button,
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@databricks/appkit-ui/react";
import { createFileRoute, retainSearchParams } from "@tanstack/react-router";
import { useEffect, useState } from "react";
import { codeToHtml } from "shiki";
import { Header } from "@/components/layout/header";

export const Route = createFileRoute("/type-safety")({
  component: TypeSafetyRoute,
  search: {
    middlewares: [retainSearchParams(true)],
  },
});

function CodeBlock({
  code,
  lang = "typescript",
}: {
  code: string;
  lang?: string;
}) {
  const [html, setHtml] = useState("");

  useEffect(() => {
    codeToHtml(code, {
      lang,
      theme: "dark-plus",
    }).then(setHtml);
  }, [code, lang]);

  return (
    <div
      className="rounded-md overflow-hidden [&>pre]:m-0 [&>pre]:p-4 [&>pre]:text-sm font-mono"
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
}

const SQL_FILE_EXAMPLE = `-- @param groupBy STRING
-- @param aggregationLevel STRING
-- @param startDate DATE
-- @param endDate DATE

SELECT
  COALESCE(:groupBy, 'default') as group_key,
  date_trunc(:aggregationLevel, usage_date) AS period,
  SUM(usage_quantity * pricing) AS cost_usd
FROM system.billing.usage
WHERE usage_date BETWEEN :startDate AND :endDate
GROUP BY period
ORDER BY period DESC`;

const GENERATED_TYPES = `// Auto-generated by AppKit - DO NOT EDIT
import "@databricks/appkit-ui/react";
import type { SQLStringMarker, SQLDateMarker } from "@databricks/appkit-ui/js";

declare module "@databricks/appkit-ui/react" {
  interface QueryRegistry {
    spend_data: {
      name: "spend_data";
      parameters: {
        /** STRING - use sql.string() */
        groupBy: SQLStringMarker;
        /** DATE - use sql.date() */
        startDate: SQLDateMarker;
        /** DATE - use sql.date() */
        endDate: SQLDateMarker;
      };
      result: Array<{
        /** @sqlType STRING */
        group_key: string;
        /** @sqlType TIMESTAMP */
        period: string;
        /** @sqlType DECIMAL */
        cost_usd: number;
      }>;
    };
  }
}`;

const USAGE_EXAMPLE = `import { sql } from "@databricks/appkit-ui/js";
import { useAnalyticsQuery } from "@databricks/appkit-ui/react";

function SpendChart() {
  const { data, loading, error } = useAnalyticsQuery("spend_data", {
    groupBy: sql.string("app_name"),
    startDate: sql.date("2024-01-01"),
    endDate: sql.date("2024-12-31"),
  });

  // data is typed as Array<{
  //   group_key: string;
  //   period: string;
  //   cost_usd: number;
  // }>

  return data?.map(row => (
    <div key={row.period}>
      {row.group_key}: \${row.cost_usd.toFixed(2)}
    </div>
  ));
}`;

function FlowStep({
  number,
  title,
  active,
}: {
  number: number;
  title: string;
  active: boolean;
}) {
  return (
    <div className="flex items-center">
      <div className="flex flex-col items-center">
        <div
          className={`w-10 h-10 rounded-full flex items-center justify-center text-primary-foreground font-semibold text-sm ${
            active ? "bg-primary" : "bg-muted-foreground/40"
          }`}
        >
          {number}
        </div>
        <span
          className={`mt-2 text-xs ${active ? "text-foreground font-medium" : "text-muted-foreground"}`}
        >
          {title}
        </span>
      </div>
    </div>
  );
}

function FlowDiagram() {
  const [activeStep, setActiveStep] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setActiveStep((prev) => (prev + 1) % 3);
    }, 2000);
    return () => clearInterval(interval);
  }, []);

  const steps = ["SQL File", "Generated Types", "IntelliSense"];

  return (
    <div className="flex items-center justify-center gap-6 py-4">
      {steps.map((step, index) => (
        <div key={step} className="flex items-center">
          <FlowStep
            number={index + 1}
            title={step}
            active={index <= activeStep}
          />
          {index < steps.length - 1 && (
            <div
              className={`w-8 h-0.5 mx-3 ${index < activeStep ? "bg-primary" : "bg-border"}`}
            />
          )}
        </div>
      ))}
    </div>
  );
}

function IntelliSenseDemo() {
  const [step, setStep] = useState(0);
  const [showAutocomplete, setShowAutocomplete] = useState(false);
  const [showParamHint, setShowParamHint] = useState(false);
  const [showResultHint, setShowResultHint] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [timeoutIds, setTimeoutIds] = useState<ReturnType<typeof setTimeout>[]>(
    [],
  );
  const [html, setHtml] = useState("");

  const queryNames = [
    "apps_list",
    "cost_recommendations",
    "spend_data",
    "spend_summary",
  ];

  const clearAllTimeouts = () => {
    for (const id of timeoutIds) {
      clearTimeout(id);
    }
    setTimeoutIds([]);
  };

  const scheduleFromStep = (fromStep: number) => {
    const ids: ReturnType<typeof setTimeout>[] = [];
    let delay = 0;

    // Step 1: Show autocomplete (500ms)
    if (fromStep < 1) {
      delay += 500;
      ids.push(
        setTimeout(() => {
          setStep(1);
          setShowAutocomplete(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before next
    }

    // Step 2: Hide autocomplete, select query (after autocomplete shown)
    if (fromStep < 2) {
      if (fromStep >= 1) delay += 2000; // If resuming from step 1
      ids.push(
        setTimeout(() => {
          setStep(2);
          setShowAutocomplete(false);
        }, delay),
      );
      delay += 500; // Wait 500ms before showing params
    }

    // Show param hints
    if (fromStep < 2 || (fromStep === 2 && !showParamHint)) {
      if (fromStep === 2) delay += 500; // If resuming from step 2
      ids.push(
        setTimeout(() => {
          setShowParamHint(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before next
    }

    // Step 3: Hide param hints, fill in params
    if (fromStep < 3) {
      if (fromStep === 2 && showParamHint) delay += 2000; // If resuming with params shown
      ids.push(
        setTimeout(() => {
          setStep(3);
          setShowParamHint(false);
        }, delay),
      );
      delay += 500; // Wait 500ms before showing results
    }

    // Show result hints
    if (fromStep < 3 || (fromStep === 3 && !showResultHint)) {
      if (fromStep === 3) delay += 500; // If resuming from step 3
      ids.push(
        setTimeout(() => {
          setShowResultHint(true);
        }, delay),
      );
      delay += 2000; // Wait 2s before complete
    }

    // Step 4: Complete
    if (fromStep < 4) {
      if (fromStep === 3 && showResultHint) delay += 2000; // If resuming with results shown
      ids.push(
        setTimeout(() => {
          setStep(4);
        }, delay),
      );
    }

    setTimeoutIds(ids);
  };

  const togglePause = () => {
    if (isPaused) {
      // Resume from current step
      setIsPaused(false);
      scheduleFromStep(step);
    } else {
      // Pause
      clearAllTimeouts();
      setIsPaused(true);
    }
  };

  const runDemo = () => {
    clearAllTimeouts();
    setIsPaused(false);
    setStep(0);
    setShowAutocomplete(false);
    setShowParamHint(false);
    setShowResultHint(false);

    scheduleFromStep(0);
  };

  // Use a unique placeholder that shiki won't transform
  const CURSOR_PLACEHOLDER = "___CURSOR___";

  // Build code based on step - show cursor where user is "typing"
  const code =
    step >= 3
      ? `const { data } = useAnalyticsQuery(
  "spend_data",
  {
    startDate: sql.date("2024-01-01"),
    endDate: sql.date("2024-12-31"),
  }
);

data?.map(row => row.${CURSOR_PLACEHOLDER})`
      : step >= 2
        ? `const { data } = useAnalyticsQuery(
  "spend_data",
  {
    ${CURSOR_PLACEHOLDER}
  }
);`
        : `const { data } = useAnalyticsQuery(
  "${CURSOR_PLACEHOLDER}"
);`;

  useEffect(() => {
    codeToHtml(code, {
      lang: "typescript",
      theme: "dark-plus",
    }).then((highlighted) => {
      // Replace placeholder with cursor HTML
      const cursorHtml = `<span class="animate-pulse bg-white/90 text-zinc-900 px-[1px]">|</span>`;
      setHtml(highlighted.replace(CURSOR_PLACEHOLDER, cursorHtml));
    });
  }, [code]);

  return (
    <div>
      <div className="relative rounded-md min-h-[300px] [&_pre]:m-0 [&_pre]:p-4 [&_pre]:text-sm [&_pre]:min-h-[300px] [&_pre]:rounded-md font-mono">
        <div
          className="overflow-hidden rounded-md"
          dangerouslySetInnerHTML={{ __html: html }}
        />

        {showAutocomplete && (
          <div className="absolute left-[88px] top-[52px] bg-[#252526] border border-[#454545] rounded shadow-lg z-10 w-56">
            <div className="text-xs text-[#858585] px-2 py-1 border-b border-[#454545]">
              QueryRegistry
            </div>
            {queryNames.map((name, i) => (
              <div
                key={name}
                className={`px-3 py-1 text-sm font-mono ${
                  i === 2 ? "bg-[#04395e] text-white" : "text-[#cccccc]"
                }`}
              >
                {name}
              </div>
            ))}
          </div>
        )}

        {showParamHint && (
          <div className="absolute left-[100px] top-[84px] bg-[#252526] border border-[#454545] rounded shadow-lg z-10 w-60">
            <div className="text-xs text-[#858585] px-2 py-1 border-b border-[#454545]">
              Parameters (spend_data)
            </div>
            <div className="p-2 text-sm font-mono text-[#cccccc]">
              <div>groupBy: SQLStringMarker</div>
              <div>startDate: SQLDateMarker</div>
              <div>endDate: SQLDateMarker</div>
            </div>
          </div>
        )}

        {showResultHint && (
          <div className="absolute left-[220px] bottom-[24px] bg-[#252526] border border-[#454545] rounded shadow-lg z-10 w-48 overflow-hidden">
            <div className="text-xs text-[#858585] px-2 py-1 border-b border-[#454545]">
              Result Fields
            </div>
            {["group_key: string", "period: string", "cost_usd: number"].map(
              (field, i) => (
                <div
                  key={field}
                  className={`px-3 py-1 text-sm font-mono ${
                    i === 2 ? "bg-[#04395e] text-white" : "text-[#cccccc]"
                  }`}
                >
                  {field}
                </div>
              ),
            )}
          </div>
        )}
      </div>

      <div className="flex items-center gap-4 mt-4">
        <Button variant="outline" size="sm" onClick={runDemo}>
          Run Demo
        </Button>
        {step > 0 && step < 4 && (
          <Button variant="outline" size="sm" onClick={togglePause}>
            {isPaused ? "Resume" : "Pause"}
          </Button>
        )}
        <span className="text-sm text-muted-foreground">
          {isPaused && "(Paused) "}
          {step === 0 && "Click to start"}
          {step === 1 && "Query name autocomplete"}
          {step === 2 && "Parameter hints"}
          {step === 3 && "Result field suggestions"}
          {step === 4 && "Complete!"}
        </span>
      </div>
    </div>
  );
}

function TypeSafetyRoute() {
  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-6xl mx-auto px-6 py-12">
        <Header
          title="Type-Safe SQL Queries"
          description="Generate TypeScript types from SQL files at build time with full IntelliSense support."
          tooltip="Demonstrates automatic type generation from SQL files using Vite plugin or npx command"
        />

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Flow Diagram */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>How It Works</CardTitle>
              <CardDescription>
                SQL files with @param annotations are processed to generate
                TypeScript types
              </CardDescription>
            </CardHeader>
            <CardContent>
              <FlowDiagram />
            </CardContent>
          </Card>

          {/* SQL File */}
          <Card>
            <CardHeader>
              <CardTitle>1. SQL File</CardTitle>
              <CardDescription>
                Write SQL queries with @param annotations to define parameter
                types
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={SQL_FILE_EXAMPLE} lang="sql" />
            </CardContent>
          </Card>

          {/* Generated Types */}
          <Card>
            <CardHeader>
              <CardTitle>2. Generated Types</CardTitle>
              <CardDescription>
                Vite plugin or npx command generates appKitTypes.d.ts at build
                time
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={GENERATED_TYPES} lang="typescript" />
            </CardContent>
          </Card>

          {/* IntelliSense Demo */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>3. IntelliSense</CardTitle>
              <CardDescription>
                Your IDE provides full autocomplete for query names, parameters,
                and results
              </CardDescription>
            </CardHeader>
            <CardContent>
              <IntelliSenseDemo />
            </CardContent>
          </Card>

          {/* Usage Example */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>Usage Example</CardTitle>
              <CardDescription>
                Type-safe queries in your React components
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock code={USAGE_EXAMPLE} lang="typescript" />
            </CardContent>
          </Card>

          {/* Vite Plugin */}
          <Card>
            <CardHeader>
              <CardTitle>Vite Plugin</CardTitle>
              <CardDescription>
                Automatic type generation during development
              </CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock
                code={`// vite.config.ts
import { appKitTypesPlugin } from '@databricks/appkit';

export default defineConfig({
  plugins: [
    appKitTypesPlugin(),
    // Optional: appKitTypesPlugin({
    //   outputFile: 'src/appKitTypes.d.ts',
    //   watchFolders: ['../config/queries'],
    // }),
  ],
});`}
              />
            </CardContent>
          </Card>

          {/* NPX Command */}
          <Card>
            <CardHeader>
              <CardTitle>NPX Command</CardTitle>
              <CardDescription>Manual or CI/CD type generation</CardDescription>
            </CardHeader>
            <CardContent>
              <CodeBlock
                code={`# Generate types from project root
npx @databricks/appkit generate-types

# Custom output path
npx @databricks/appkit generate-types . client/src/types.d.ts

# Force regeneration (skip cache)
npx @databricks/appkit generate-types --no-cache`}
                lang="bash"
              />
            </CardContent>
          </Card>

          {/* Supported Types */}
          <Card className="md:col-span-2">
            <CardHeader>
              <CardTitle>Supported Parameter Types</CardTitle>
              <CardDescription>
                Use @param annotations in SQL files to define typed parameters
              </CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                {[
                  { annotation: "@param name STRING", helper: "sql.string()" },
                  {
                    annotation: "@param count NUMERIC",
                    helper: "sql.number()",
                  },
                  {
                    annotation: "@param active BOOLEAN",
                    helper: "sql.boolean()",
                  },
                  { annotation: "@param start DATE", helper: "sql.date()" },
                  {
                    annotation: "@param created TIMESTAMP",
                    helper: "sql.timestamp()",
                  },
                  { annotation: "@param data BINARY", helper: "sql.binary()" },
                ].map((type) => (
                  <div key={type.annotation} className="p-3 bg-muted rounded">
                    <code className="text-xs text-muted-foreground block">
                      -- {type.annotation}
                    </code>
                    <code className="text-sm text-foreground font-medium">
                      {type.helper}
                    </code>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
