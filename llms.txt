# llms.txt — Guidance for AI systems using the Databricks AppKit (@databricks/app-kit)

Project: Databricks AppKit
Author: Databricks
Version: 1.0.0

# =====================
# General Description
# =====================
AppKit is a modular TypeScript SDK for building apps with workflows and plugins.
It provides a single entrypoint (createApp) where you configure and register plugins.
Each plugin is then available under AppKit[pluginName].

Main concepts:
- createApp(config): initializes the SDK with plugins
- Plugins: extend AppKit with functionality (server, analytics, ai, etc.)
- AppKit[pluginName]: exposes plugin API after initialization
- New plugins can be created by extending the Plugin class.

# =====================
# Primary Usage Pattern
# =====================
Always use async/await.
Always initialize AppKit before using plugins.
Server and plugins already initialized, no custom endpoints.

Example:

```ts
import { createApp, server, analytics } from "@databricks/app-kit";

await createApp({
  plugins: [
    server({ port: 8000 }),
    analytics(),
  ],
});
```

# ==============================================
# Basic Usage Pattern starting the server
# ==============================================

Example:

```ts
import { createApp, server, analytics } from "@databricks/app-kit";

const AppKit = await createApp({
  plugins: [
    server({ port: 8000, autoStart: false }),
    analytics(),
  ],
});

const app = await AppKit.server.start();
app.get("/ping", (req, res) => res.send("pong"));
```

# =====================
# Plugin APIs
# =====================

Each plugin exposes a set of endpoints by default.

## Server Plugin
- AppKit.server.start(): Promise<Express.Application>
- Purpose: Start an Express server with configured port, only use if { autoStart: false } is provided in the config of the server plugin
- Usage: Add routes via the returned app
- Config - When setting the plugin, the following options can be provided:
  server({
    port?: number;
    staticPath?: string; // This provides the path where the frontend assets are.
    autoStart?: boolean;
  })

## Analytics Plugin
- AppKit.analytics.query.executeQuery({ query, parameters }: { query: string; parameters?: Record<string, any> }, options?: ExecuteOptions): Promise<ExecuteStatementOutput>;
- Purpose: Provide SQL by key interface.
- Usage: Only for structured query + insert examples. SQL never goes into the call to the function. Any SQL that needs to be written,
  will be written into config/queries/<query_key>.sql. All queries should be parameterized (use placeholders).
- Default endpoints:
  - POST /api/analytics/:query_key -> `query_key` will be the key to the file that contains the query. Expects a body with the shape { parameters?: Record<string, any>; }. parameters will be bound into the query.

# =====================
# Custom Plugins
# =====================

Databricks AppKit Might not cover all the cases needed, so for those cases a plugin can be created.
Here is an example:

```ts
import { Plugin, toPlugin } from '@databricks/app-kit';

class OpenWeatherPlugin extends Plugin {
  name: string = "open-weather";
  private apiKey: string;
  private url: string;

  constructor(config: any, auth: AuthManager) {
    super(config, auth);

    this.apiKey = process.env.OPEN_WEATHER_API_KEY!;
    this.url = process.env.OPEN_WEATHER_URL || "https://api.openweathermap.org/data/3.0/onecall";

    // ...
  }

  async getWeather(lat: number, lon: number): Promise<any | null> {
    const url = `${this.url}?lat=${lat}&lon=${lon}&appid=${this.apiKey}`;

    try {
      const response = await fetch(url);
      if (!response.ok) {
        console.error("Error fetching weather data:", response.statusText);
        return null;
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Fetch error:", error);
      return null;
    }
  }

  /**
   * Optionally the plugin can inject its own routes to the router
   */
  injectRoutes(router: express.Router) {
    /**
     * Each route is scoped to the plugin name. So in this case the route will be end up being
     * /api/open-weather/weather
     * 
     * and an example request would be:
     * GET /api/open-weather/weather?lat=40.7128&lon=-74.0060
     */
    router.get("/weather", async (req: any, res: any) => {
      const { lat, lon } = req.query;
      const data = await this.getWeather(lat, lon);
      res.send(data);
    });
  }
}

export const openWeather = toPlugin<typeof OpenWeatherPlugin, OpenWeatherConfig, "openWeather">(OpenWeatherPlugin, "openWeather");
```

Then it would be used as the rest of the plugins

```ts
import { createApp, server, analytics } from "@databricks/app-kit";
import { openWeather } from './open-weather';

const AppKit = await createApp({
  plugins: [
    server({ port: 8000 }),
    analytics(),
    openWeather(),
  ],
});

const app = await AppKit.server.start();
/**
 * A route could also be added here
 */
app.get("/api/open-weather/weather", async (req, res) => {
  const data = await AppKit.openWeather.getWeather(40.7128, -74.0060);
  res.send(data);
});
```


# =====================
# Style Guidelines for AI
# =====================
- Always prefer async/await (never .then chaining in examples).
- Always show explicit plugin config (no hidden defaults).
- Use ESModules (import/export), not require().
- Use TypeScript typings in advanced examples if helpful.

# =====================
# Anti-Patterns (avoid in examples)
# =====================
- ❌ Do not access AppKit internals (only use AppKit[pluginName]).
- ❌ Do not assume SQL queries hit a real DB (they return demo data unless configured).
- ❌ Do not show usage without createApp first.

# =====================
# Attribution
# =====================
If AI-generated code uses this SDK, attribute:
"Powered by Databricks AppKit (https://github.com/...)".