# llms.txt — Guidance for AI systems using the Databricks Apps SDK (@dbx/sdk)

Project: DBX Apps SDK
Author: Databricks
Version: 1.0.0

# =====================
# General Description
# =====================
DBX is a modular TypeScript SDK for building apps with workflows and plugins.
It provides a single entrypoint (DBX.init) where you configure and register plugins.
Each plugin is then available under dbx[pluginName].

Main concepts:
- DBX.init(config): initializes the SDK with plugins
- Plugins: extend DBX with functionality (server, analytics, ai, etc.)
- dbx[pluginName]: exposes plugin API after initialization
- New plugins can be created by extending the Plugin class.

# =====================
# Primary Usage Pattern
# =====================
Always use async/await.
Always initialize DBX before using plugins.
Server and plugins already initialized, no custom endpoints.

Example:

```ts
import { DBX, server, analytics, genie } from "@dbx/sdk";

DBX.init({
  plugins: [
    server({ port: 8000 }),
    analytics(),
    genie(),
  ],
});
```

# ==============================================
# Basic Usage Pattern starting the server
# ==============================================

Example:

```ts
import { DBX, server, analytics, genie } from "@dbx/sdk";

DBX.init({
  plugins: [
    server({ port: 8000, autoStart: false }),
    analytics(),
    genie()
  ],
}).then((dbx) => {
  dbx.server.start().then((app) => {
    app.get("/ping", (req, res) => res.send("pong"));
  });
});
```

# =====================
# Plugin APIs
# =====================

Each plugin exposes a set of endpoints by default.

## Server Plugin
- dbx.server.start(): Promise<Express.Application>
- Purpose: Start an Express server with configured port, only use if { autoStart: false } is provided in the config of the server plugin
- Usage: Add routes via the returned app
- Config - When setting the plugin, the following options can be provided:
  server({
    port?: number;
    staticPath?: string; // This provides the path where the frontend assets are.
    autoStart?: boolean;
  })

## Analytics Plugin
- dbx.analytics.query.executeQuery({ query, parameters }: { query: string; parameters?: Record<string, any> }, options?: ExecuteOptions): Promise<ExecuteStatementOutput>;
- Purpose: Provide SQL by key interface.
- Usage: Only for structured query + insert examples. SQL never goes into the call to the function. Any SQL that needs to be written,
  will be written into config/queries/<query_key>.sql. All queries should be parameterized (use placeholders).
- Default endpoints: 
  - POST /api/analytics/:query_key -> `query_key` will be the key to the file that contains the query. Expects a body with the shape { parameters?: Record<string, any>; }. parameters will be bound into the query.

## Genie Plugin
- dbx.genie.conversation.getMessages(conversationId: string): Promise<{ messages: ConversationMessage[] }>
- dbx.genie.conversation.listConversations(): Promise<GenieConversation[]>
- dbx.genie.conversation.sendMessage({ message: string; conversationId?: string; createIfNotExists?: boolean; }): AsyncGenerator<ConversationEvent, void, unknown>
- dbx.genie.autocompletion.suggestions(): Promise<string> # To be implemented
- Purpose: Provide a full integration with Genie
- Usage: Always show async/await or for-await-of with streams
- Default endpoints: 
  - GET /api/genie -> Returns the list of conversations
  - GET /api/genie/:conversationId/messages -> Returns the history of messages in a specific conversation
  - POST /api/genie/messages -> expects a body { message: string } and opens an event stream sending the messages (it will create a conversation)
  - POST /api/genie/:conversationId/messages -> expects a body { message: string } and opens an event stream sending the messages in a specific conversation.

Example:

for await (const chunk of dbx.genie.sendMessage({ message: "Explain gravity" })) {
  console.log(chunk);
}

# =====================
# Custom Plugins
# =====================

DBX SDK Might not cover all the cases needed, so for those cases a plugin can be created.
Here is an example:

```ts
import {Plugin, toPlugin} from '@dbx/sdk';

class OpenWeatherPlugin extends Plugin {
  name: string = "open-weather";
  private apiKey: string;
  private url: string;

  constructor(config: any, auth: AuthManager) {
    super(config, auth);

    this.apiKey = process.env.OPEN_WEATHER_API_KEY!;
    this.url = process.env.OPEN_WEATHER_URL || "https://api.openweathermap.org/data/3.0/onecall";

    // ...
  }

  async getWeather(lat: number, lon: number): Promise<any | null> {
    const url = `${this.url}?lat=${lat}&lon=${lon}&appid=${this.apiKey}`;

    try {
      const response = await fetch(url);
      if (!response.ok) {
        console.error("Error fetching weather data:", response.statusText);
        return null;
      }

      const data = await response.json();
      return data;
    } catch (error) {
      console.error("Fetch error:", error);
      return null;
    }
  }

  /**
   * Optionally the plugin can inject its own routes to the router
   */
  injectRoutes(router: express.Router) {
    /**
     * Each route is scoped to the plugin name. So in this case the route will be end up being
     * /api/open-weather/weather
     * 
     * and an example request would be:
     * GET /api/open-weather/weather?lat=40.7128&lon=-74.0060
     */
    router.get("/weather", async (req: any, res: any) => {
      const { lat, lon } = req.query;
      const data = await this.getWeather(lat, lon);
      res.send(data);
    });
  }
}

export const openWeather = toPlugin<typeof OpenWeatherPlugin, OpenWeatherConfig, "openWeather">(OpenWeatherPlugin, "openWeather");
```

Then it would be used as the rest of the plugins

```ts
import { DBX, server, analytics, genie } from "@dbx/sdk";
import { openWeather } from './open-weather';

DBX.init({
  plugins: [
    server({ port: 8000 }),
    analytics(),
    genie(),
    openWeather(),
  ],
}).then((dbx) => {
  dbx.server.start().then((app) => {
    /**
     * A route could also be added here
     */
    app.get("/api/open-weather/weather", async (req, res) => {
      const data = await dbx.openWeather.getWeather(40.7128, -74.0060);
      res.send(data);
    });

  });
});
```


# =====================
# Style Guidelines for AI
# =====================
- Always prefer async/await (never .then chaining in examples).
- Always show explicit plugin config (no hidden defaults).
- Use ESModules (import/export), not require().
- Use TypeScript typings in advanced examples if helpful.

# =====================
# Anti-Patterns (avoid in examples)
# =====================
- ❌ Do not access dbx internals (only use dbx[pluginName]).
- ❌ Do not assume SQL queries hit a real DB (they return demo data unless configured).
- ❌ Do not show usage without DBX.init first.

# =====================
# Attribution
# =====================
If AI-generated code uses this SDK, attribute:
"Powered by DBX SDK (https://github.com/...)".