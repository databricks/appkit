import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import * as docgen from "react-docgen-typescript";

type ComponentDoc = docgen.ComponentDoc;

const GITHUB_REPO_URL = "https://github.com/databricks/appkit/blob/main";
const COMPONENTS_EXAMPLES_DIR = "packages/appkit-ui/src/react/ui/examples";
const COMPONENTS_DIR = "packages/appkit-ui/src/react/ui";
const CHARTS_DIR = "packages/appkit-ui/src/react/charts";
const TABLE_DIR = "packages/appkit-ui/src/react/table";
const DOCS_OUTPUT_DIR = "docs/docs/api/appkit-ui";

const SOURCE_DIRS = [
  { name: "ui", path: COMPONENTS_DIR },
  { name: "charts", path: CHARTS_DIR },
  { name: "table", path: TABLE_DIR },
] as const;

const FILE_EXTENSIONS = {
  TSX: ".tsx",
  EXAMPLE: ".example.tsx",
  TEST_PATTERN: ".test.",
  INDEX: "/index.tsx",
} as const;

const COMPONENT_PATTERNS = {
  DOC_SUFFIX: "Doc",
  CHART_SUFFIX: "Chart",
  EXAMPLE_SUFFIX: "Example",
  DEFAULT_NAME: "Component",
} as const;

const PATH_PATTERNS = {
  CHARTS_DIR: "src/react/charts/",
  TABLE_DIR: "src/react/table/",
  DATA_TABLE_FILE: "data-table.tsx",
  REACT_TYPES: "@types/react",
} as const;

const OUTPUT_SUBDIRS = {
  DATA: "data",
  UI: "ui",
  EXAMPLES: "examples",
} as const;

const PACKAGE_NAMES = {
  APPKIT_UI: "@databricks/appkit-ui",
  TSCONFIG: "packages/appkit-ui/tsconfig.json",
  DOC_EXAMPLE_PATH: "docs/src/components/DocExample",
  DOC_EXAMPLE_IMPORT: "@site/src/components/DocExample",
  EXAMPLES_REGISTRY: "docs/src/components/DocExample/examples.gen.ts",
} as const;

const MARKDOWN = {
  REQUIRED_CHECKMARK: "✓",
  EMPTY_VALUE: "-",
  FILE_ENCODING: "utf-8",
  GENERATED_HEADER: "/* Auto-generated by tools/generate-component-mdx.ts */",
} as const;

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

const parser = docgen.withCustomConfig(
  path.join(repoRoot, PACKAGE_NAMES.TSCONFIG),
  {
    savePropValueAsString: true,
    shouldExtractLiteralValuesFromEnum: true,
    shouldRemoveUndefinedFromOptional: true,
    propFilter: (prop) => {
      if (prop.parent) {
        return !prop.parent.fileName.includes(PATH_PATTERNS.REACT_TYPES);
      }
      return true;
    },
  },
);

function toGithubPath(component: ComponentDoc): string {
  const filePath = component.filePath || "";
  return path.relative(repoRoot, filePath);
}

function stripDocSuffix(name: string): string {
  return name.endsWith(COMPONENT_PATTERNS.DOC_SUFFIX)
    ? name.slice(0, -COMPONENT_PATTERNS.DOC_SUFFIX.length)
    : name;
}

type ComponentCategory = "chart" | "table" | "ui";

interface ComponentInfo {
  category: ComponentCategory;
  subdir: string; // "data" or "ui"
  chartDir?: string; // Only for charts
}

function categorizeComponent(component: ComponentDoc): ComponentInfo {
  const filePath = component.filePath || "";
  const relativePath = path.relative(repoRoot, filePath);

  const chartsMatch = relativePath.match(/charts\/([^/]+)\/index\.tsx$/);
  if (chartsMatch) {
    return {
      category: "chart",
      subdir: OUTPUT_SUBDIRS.DATA,
      chartDir: chartsMatch[1],
    };
  }

  if (relativePath.includes("table/")) {
    return { category: "table", subdir: OUTPUT_SUBDIRS.DATA };
  }

  return { category: "ui", subdir: OUTPUT_SUBDIRS.UI };
}

function applySanitizationReplacements(text: string): string {
  return text
    .replace(/\{@link\s+([^}]+)\}/g, "$1")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\{/g, "&#123;")
    .replace(/\}/g, "&#125;");
}

function sanitizeDescriptionText(text: string): string {
  // Extract only the first paragraph (before first blank line)
  const firstParagraph = text.split(/\n\s*\n/)[0];
  return applySanitizationReplacements(firstParagraph)
    .replace(/\s+/g, " ")
    .trim();
}

function sanitizeDescriptionFull(text: string): string {
  return applySanitizationReplacements(text);
}

function buildPropsSection(
  props: ComponentDoc["props"],
  headingLevel = 2,
): string {
  const entries = Object.entries(props);
  const headingPrefix = "#".repeat(headingLevel);

  if (entries.length === 0) {
    return `
${headingPrefix} Props

This component extends standard HTML element attributes.
`;
  }

  const rows = entries
    .map(([name, prop]) => {
      const typeStr = prop.type.name.replace(/\|/g, "\\|");
      const required = prop.required ? MARKDOWN.REQUIRED_CHECKMARK : "";
      const defaultVal = prop.defaultValue?.value
        ? `\`${prop.defaultValue.value}\``
        : MARKDOWN.EMPTY_VALUE;
      const desc = prop.description
        ? sanitizeDescriptionText(prop.description)
        : MARKDOWN.EMPTY_VALUE;
      return `| \`${name}\` | \`${typeStr}\` | ${required} | ${defaultVal} | ${desc} |`;
    })
    .join("\n");

  return `
${headingPrefix} Props

| Prop | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
${rows}
`;
}

function buildUsageSection(displayName: string, headingLevel = 2): string {
  const headingPrefix = "#".repeat(headingLevel);
  const actualName = stripDocSuffix(displayName);
  return `
${headingPrefix} Usage

\`\`\`tsx
import { ${actualName} } from '${PACKAGE_NAMES.APPKIT_UI}';

<${actualName} /* props */ />
\`\`\`
`;
}

function buildComponentDetails(
  component: ComponentDoc,
  opts?: { propsHeadingLevel?: number; usageHeadingLevel?: number },
): string {
  const description = component.description
    ? sanitizeDescriptionFull(component.description)
    : "";
  const relativePath = toGithubPath(component);
  const propsSection = buildPropsSection(
    component.props,
    opts?.propsHeadingLevel,
  );
  const usageSection = buildUsageSection(
    component.displayName || COMPONENT_PATTERNS.DEFAULT_NAME,
    opts?.usageHeadingLevel,
  );

  return `${description ? `${description}\n\n` : ""}
**Source:** [\`${relativePath}\`](${GITHUB_REPO_URL}/${relativePath})

${propsSection}

${usageSection}`;
}

interface ExampleInfo {
  name: string;
  path: string;
}

function buildExampleInfo(component: ComponentDoc): ExampleInfo | undefined {
  const filePath = component.filePath;
  if (!filePath) return undefined;

  const baseName = path.basename(filePath, path.extname(filePath));
  const info = categorizeComponent(component);

  // UI components
  if (info.category === "ui") {
    const examplePath = path.join(
      repoRoot,
      COMPONENTS_EXAMPLES_DIR,
      `${baseName}${FILE_EXTENSIONS.EXAMPLE}`,
    );
    return fs.existsSync(examplePath)
      ? { name: baseName, path: examplePath }
      : undefined;
  }

  // Chart components
  if (info.category === "chart" && info.chartDir) {
    const chartExamplesDir = path.join(
      repoRoot,
      CHARTS_DIR,
      info.chartDir,
      OUTPUT_SUBDIRS.EXAMPLES,
    );
    const exampleName = stripDocSuffix(component.displayName || "")
      .replace(new RegExp(`${COMPONENT_PATTERNS.CHART_SUFFIX}$`), "")
      .toLowerCase();

    // Try component-specific first, then directory-based
    for (const name of [exampleName, info.chartDir]) {
      const examplePath = path.join(
        chartExamplesDir,
        `${name}${FILE_EXTENSIONS.EXAMPLE}`,
      );
      if (fs.existsSync(examplePath)) return { name, path: examplePath };
    }
  }

  // Table components
  if (info.category === "table") {
    const tableExamplesDir = path.join(
      repoRoot,
      TABLE_DIR,
      OUTPUT_SUBDIRS.EXAMPLES,
    );
    const examplePath = path.join(
      tableExamplesDir,
      `${baseName}${FILE_EXTENSIONS.EXAMPLE}`,
    );
    return fs.existsSync(examplePath)
      ? { name: baseName, path: examplePath }
      : undefined;
  }

  return undefined;
}

function generateGroupedComponentPage(
  groupName: string,
  components: ComponentDoc[],
  example?: ExampleInfo,
  subdir?: string,
): string {
  const sections = components
    .map((component) => {
      const displayName = stripDocSuffix(component.displayName || "");

      return `## ${displayName}

${buildComponentDetails(component, {
  propsHeadingLevel: 3,
  usageHeadingLevel: 3,
})}`;
    })
    .join("\n\n");

  // Generate example section based on component type
  let exampleSection = "";
  if (example) {
    if (subdir === OUTPUT_SUBDIRS.DATA) {
      // For data components: show code only (no interactive preview)
      const sourceCode = fs.readFileSync(example.path, MARKDOWN.FILE_ENCODING);
      exampleSection = `
## Example

\`\`\`tsx
${sourceCode}
\`\`\`

`;
    } else {
      // For UI components: show interactive preview
      exampleSection = `
## Example

import { DocExample } from "${PACKAGE_NAMES.DOC_EXAMPLE_IMPORT}";

<DocExample name="${example.name}" />

`;
    }
  }

  const pageDescription = components[0]?.description
    ? `${sanitizeDescriptionText(components[0].description)}\n\n`
    : "";

  return `# ${groupName}

${pageDescription}${exampleSection}
${sections}
`;
}

function findTsxFiles(dir: string) {
  const files: string[] = [];

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...findTsxFiles(fullPath)); // FIX: Collect recursive results
    } else if (
      entry.name.endsWith(FILE_EXTENSIONS.TSX) &&
      !entry.name.includes(FILE_EXTENSIONS.TEST_PATTERN)
    ) {
      files.push(fullPath);
    }
  }

  return files;
}

function findExampleFiles(
  dir: string,
): Array<{ file: string; fullPath: string }> {
  const results: Array<{ file: string; fullPath: string }> = [];

  if (!fs.existsSync(dir)) {
    return results;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...findExampleFiles(fullPath));
    } else if (entry.name.endsWith(FILE_EXTENSIONS.EXAMPLE)) {
      results.push({ file: entry.name, fullPath });
    }
  }

  return results;
}

function baseNameToComponentName(baseName: string): string {
  return baseName
    .split("-")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

function generateExamplesRegistry() {
  const outputPath = path.join(repoRoot, PACKAGE_NAMES.EXAMPLES_REGISTRY);

  // Collect examples from all directories
  const allExamples = SOURCE_DIRS.flatMap((dir) =>
    findExampleFiles(path.join(repoRoot, dir.path)),
  );
  allExamples.sort((a, b) => a.file.localeCompare(b.file));

  // Generate import statements
  const imports = allExamples
    .map(({ file, fullPath }) => {
      const baseName = path.basename(file, FILE_EXTENSIONS.EXAMPLE);
      const componentName = baseNameToComponentName(baseName);
      const importName = `${componentName}${COMPONENT_PATTERNS.EXAMPLE_SUFFIX}`;
      const relativePath = path.relative(
        path.join(repoRoot, PACKAGE_NAMES.DOC_EXAMPLE_PATH),
        fullPath.replace(FILE_EXTENSIONS.TSX, ""),
      );
      return `import ${importName} from "${relativePath}";`;
    })
    .join("\n");

  // Read example source code
  const exampleEntries = allExamples.map(({ file, fullPath }) => {
    const baseName = path.basename(file, FILE_EXTENSIONS.EXAMPLE);
    const componentName = baseNameToComponentName(baseName);
    const importName = `${componentName}${COMPONENT_PATTERNS.EXAMPLE_SUFFIX}`;
    const sourceCode = fs.readFileSync(fullPath, MARKDOWN.FILE_ENCODING);

    // Escape backticks and backslashes in source code
    const escapedSource = sourceCode
      .replace(/\\/g, "\\\\")
      .replace(/`/g, "\\`")
      .replace(/\$/g, "\\$");

    return `  "${baseName}": {
    Component: ${importName},
    source: \`${escapedSource}\`,
  }`;
  });

  // Generate the registry file
  const content = `${MARKDOWN.GENERATED_HEADER}
import type { ComponentType } from "react";
${imports}

export type AppKitExampleEntry = {
  Component: ComponentType;
  source: string;
};

export const examples: Record<string, AppKitExampleEntry> = {
${exampleEntries.join(",\n")}
};

export type AppKitExampleKey = keyof typeof examples;
`;

  fs.writeFileSync(outputPath, content, MARKDOWN.FILE_ENCODING);
  console.log(
    `Generated examples registry at ${path.relative(repoRoot, outputPath)}`,
  );
}

function main() {
  const outputDir = path.join(repoRoot, DOCS_OUTPUT_DIR);

  // Scan all directories
  const allFiles = SOURCE_DIRS.flatMap((dir) =>
    findTsxFiles(path.join(repoRoot, dir.path)),
  );
  const componentDocs = parser.parse(allFiles);

  // Generate examples registry first
  generateExamplesRegistry();

  // Filter out non-components (e.g., lifecycle methods incorrectly detected)
  const excludeList = [
    "componentDidMount",
    "componentDidUpdate",
    "componentWillUnmount",
  ];

  const validComponents = componentDocs.filter((component) => {
    const displayName = component.displayName || "";
    const filePath = component.filePath || "";
    const info = categorizeComponent(component);

    // Exclude internal utility files from charts/table directories
    // Only include chart components from index.tsx files
    if (
      filePath.includes(PATH_PATTERNS.CHARTS_DIR) &&
      !filePath.endsWith(FILE_EXTENSIONS.INDEX)
    ) {
      return false;
    }

    // Exclude internal utility files from table directory
    if (
      filePath.includes(PATH_PATTERNS.TABLE_DIR) &&
      !filePath.match(new RegExp(`${PATH_PATTERNS.DATA_TABLE_FILE}$`))
    ) {
      return false;
    }

    return (
      Boolean(displayName) &&
      !excludeList.includes(displayName) &&
      !component.filePath?.includes(FILE_EXTENSIONS.EXAMPLE) &&
      // For charts: only include *Doc components
      (info.category === "chart"
        ? displayName.endsWith(COMPONENT_PATTERNS.DOC_SUFFIX)
        : true)
    );
  });

  const sortedComponents = [...validComponents].sort((a, b) =>
    (a.displayName ?? "").localeCompare(b.displayName ?? ""),
  );
  const componentsByFile = new Map<string, ComponentDoc[]>();

  sortedComponents.forEach((component) => {
    const filePath = component.filePath || "";
    const displayName = component.displayName || "";
    const info = categorizeComponent(component);

    // For Doc components from charts, use display name as key (separate pages)
    // For other components, group by file path
    const key =
      info.category === "chart" &&
      displayName.endsWith(COMPONENT_PATTERNS.DOC_SUFFIX)
        ? displayName // Each Doc component gets its own page
        : filePath || displayName; // Other components grouped by file

    if (!componentsByFile.has(key)) {
      componentsByFile.set(key, []);
    }

    componentsByFile.get(key)?.push(component);
  });

  function getOutputSubdir(component: ComponentDoc): string {
    return categorizeComponent(component).subdir;
  }

  function toPageName(key: string): string {
    const components = componentsByFile.get(key);
    if (components?.[0]) {
      const displayName = components[0].displayName || "";
      const strippedName = stripDocSuffix(displayName);
      if (strippedName) {
        return strippedName;
      }
    }

    // Fallback to filename-based name
    const baseName = path.basename(key, path.extname(key));
    const pascal = baseName
      .split(/[^a-zA-Z0-9]+/)
      .filter(Boolean)
      .map((segment) => segment[0].toUpperCase() + segment.slice(1))
      .join("");
    return pascal || COMPONENT_PATTERNS.DEFAULT_NAME;
  }

  const outputPageNames: string[] = [];

  // Create output directory if it doesn't exist
  fs.mkdirSync(outputDir, { recursive: true });

  // Delete only subdirectories (preserve files like index.md)
  if (fs.existsSync(outputDir)) {
    const entries = fs.readdirSync(outputDir, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isDirectory()) {
        fs.rmSync(path.join(outputDir, entry.name), {
          recursive: true,
          force: true,
        });
      }
    }
  }

  // Create subdirectories
  const dataOutputDir = path.join(outputDir, OUTPUT_SUBDIRS.DATA);
  const uiOutputDir = path.join(outputDir, OUTPUT_SUBDIRS.UI);
  fs.mkdirSync(dataOutputDir, { recursive: true });
  fs.mkdirSync(uiOutputDir, { recursive: true });

  let count = 0;

  const fileNameCounts = new Map<string, number>();
  const sortedKeys = [...componentsByFile.keys()].sort((a, b) =>
    toPageName(a).localeCompare(toPageName(b)),
  );

  for (const key of sortedKeys) {
    const components = componentsByFile.get(key);
    if (!components) continue;
    const pageName = toPageName(key);
    const countForName = fileNameCounts.get(pageName) ?? 0;
    fileNameCounts.set(pageName, countForName + 1);
    const outputName =
      countForName === 0 ? pageName : `${pageName}${countForName + 1}`;

    const sortedMembers = [...components].sort((a, b) =>
      (a.displayName ?? "").localeCompare(b.displayName ?? ""),
    );
    const exampleInfo = sortedMembers[0]
      ? buildExampleInfo(sortedMembers[0])
      : undefined;

    // Determine subdirectory based on first component's source
    const subdir = sortedMembers[0]
      ? getOutputSubdir(sortedMembers[0])
      : OUTPUT_SUBDIRS.UI;
    const outputPath = path.join(outputDir, subdir, `${outputName}.mdx`);

    try {
      fs.writeFileSync(
        outputPath,
        generateGroupedComponentPage(
          pageName,
          sortedMembers,
          exampleInfo,
          subdir,
        ),
        MARKDOWN.FILE_ENCODING,
      );
      outputPageNames.push(`${subdir}/${outputName}`);
      count++;
    } catch (error) {
      console.error(`✗ Failed to write ${outputName}.mdx:`, error);
    }
  }

  const relativeOutputDir = path.relative(repoRoot, outputDir);
  console.log(
    `\nGenerated ${count} component MDX files in ${relativeOutputDir}`,
  );
}

main();
