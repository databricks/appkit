import { readFile, writeFile, mkdir } from "node:fs/promises";
import { createHash } from "node:crypto";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import postcss from "postcss";
import tailwindcss from "@tailwindcss/postcss";

const __dirname = dirname(fileURLToPath(import.meta.url));

async function buildStyles(): Promise<void> {
  try {
    const sourceCSS = resolve(
      __dirname,
      "../../packages/appkit-ui/src/react/styles/globals.css",
    );
    const outputDir = resolve(__dirname, "../static/appkit-ui");
    const outputCSS = resolve(outputDir, "styles.gen.css");

    let css = await readFile(sourceCSS, "utf-8");

    // Rewrite @source path for docs build
    // The original @source "./react" is correct for the package, but during docs build
    // we need @source "../" because the CSS file path context is different during PostCSS
    // processing. This allows Tailwind to find and scan the React component files in
    // packages/appkit-ui/src/react to generate all the utility classes they use.
    css = css.replace('@source "./react"', '@source "../"');

    const result = await postcss([tailwindcss()]).process(css, {
      from: sourceCSS,
      to: outputCSS,
    });

    await mkdir(outputDir, { recursive: true });

    // Extract theme variables from @theme inline block in source
    // These variables need to be manually injected because Tailwind v4's @theme inline
    // processing doesn't fully preserve all the custom color mappings
    const themeVarsMatch = css.match(/@theme inline\s*\{([^}]+)\}/s);
    let finalCSS = result.css;

    if (themeVarsMatch) {
      const themeVars = themeVarsMatch[1].trim();

      // Inject theme variables into the @layer theme block's :root, :host selector
      finalCSS = finalCSS.replace(
        /(@layer theme\s*\{\s*:root,\s*:host\s*\{[^}]*)(}\s*})/,
        (match, before, after) => {
          // Add proper indentation (4 spaces) to each line
          const indentedVars = themeVars
            .split("\n")
            .map((line) => {
              const trimmed = line.trim();
              return trimmed ? `    ${trimmed}` : "";
            })
            .filter((line) => line) // Remove empty lines
            .join("\n");
          return `${before}\n${indentedVars}\n  ${after}`;
        },
      );
    }

    // Add comment after PostCSS processing so it doesn't get stripped out
    finalCSS = `/* Auto-generated by docs/scripts/build-appkit-ui-styles.ts */\n${finalCSS}`;

    // Generate content hash for cache busting
    const cssVersion = createHash("md5")
      .update(finalCSS)
      .digest("hex")
      .substring(0, 8);

    // Write CSS file
    await writeFile(outputCSS, finalCSS, "utf-8");

    // Write version file for cache busting
    const versionFile = resolve(outputDir, "styles.version.json");
    await writeFile(
      versionFile,
      JSON.stringify({ version: cssVersion }, null, 2),
      "utf-8",
    );

    console.log(
      `[build-appkit-ui-styles] ✓ appkit-ui CSS build complete! Version: ${cssVersion}; Output size: ${(result.css.length / 1024).toFixed(2)} KB`,
    );
  } catch (error) {
    console.error("[build-styles] ✗ Error building styles:", error);
    process.exit(1);
  }
}

buildStyles();
