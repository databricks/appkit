import fs from "node:fs";
import dotenv from "dotenv";
import { generateQueriesFromDescribe } from "./query-registry";
import type { QuerySchema } from "./types";

dotenv.config();

/** Plugin endpoints schema from server */
interface PluginEndpoints {
  [pluginName: string]: {
    [endpointName: string]: string;
  };
}

/**
 * Extract path parameters from a URL template.
 * e.g., "/api/analytics/query/:query_key" -> ["query_key"]
 */
function extractPathParams(template: string): string[] {
  const matches = template.match(/:([a-zA-Z_][a-zA-Z0-9_]*)/g);
  return matches ? matches.map((m) => m.slice(1)) : [];
}

/**
 * Generate AppKitPlugins type declarations from endpoint schema.
 */
function generatePluginTypes(endpoints: PluginEndpoints): string {
  const pluginEntries = Object.entries(endpoints)
    .filter(([, pluginEndpoints]) => Object.keys(pluginEndpoints).length > 0)
    .map(([pluginName, pluginEndpoints]) => {
      const endpointEntries = Object.entries(pluginEndpoints)
        .map(([endpointName, template]) => {
          const params = extractPathParams(template);
          if (params.length === 0) {
            return `      ${endpointName}: EndpointFn;`;
          }
          const paramType = `{ ${params
            .map((p) => `${p}: string`)
            .join("; ")} }`;
          return `      ${endpointName}: EndpointFn<${paramType}>;`;
        })
        .join("\n");

      // Handle plugin names with hyphens by quoting them
      const quotedName = pluginName.includes("-")
        ? `"${pluginName}"`
        : pluginName;

      return `    ${quotedName}: {\n${endpointEntries}\n    };`;
    })
    .join("\n");

  if (!pluginEntries) return "";

  return `
declare module "@databricks/app-kit-ui/js" {
  interface AppKitPlugins {
${pluginEntries}
  }
}
`;
}

/**
 * Generate type declarations for QueryRegistry and AppKitPlugins
 * Create the d.ts file from the plugin routes and query schemas
 * @param querySchemas - the list of query schemas
 * @param endpoints - the plugin endpoints schema
 * @returns - the type declarations as a string
 */
function generateTypeDeclarations(
  querySchemas: QuerySchema[] = [],
  endpoints: PluginEndpoints = {},
): string {
  const queryEntries = querySchemas
    .map(({ name, type }) => {
      const indentedType = type
        .split("\n")
        .map((line, i) => (i === 0 ? line : `    ${line}`))
        .join("\n");
      return `    ${name}: ${indentedType}`;
    })
    .join(";\n");

  const querySection = queryEntries ? `\n${queryEntries};\n  ` : "";
  const pluginTypesSection = generatePluginTypes(endpoints);

  return `// Auto-generated by AppKit - DO NOT EDIT
// Generated by 'npx appkit-generate-types' or Vite plugin during build
import "@databricks/app-kit-ui/react";
import "@databricks/app-kit-ui/js";
import type { SQLTypeMarker, SQLStringMarker, SQLNumberMarker, SQLBooleanMarker, SQLBinaryMarker, SQLDateMarker, SQLTimestampMarker, EndpointFn } from "@databricks/app-kit-ui/js";
${pluginTypesSection}
declare module "@databricks/app-kit-ui/react" {
  interface QueryRegistry {${querySection}}
}
`;
}

/**
 * Fetch the schema from a running server.
 * @param serverUrl - the server URL (e.g., http://localhost:8000)
 * @param timeoutMs - timeout in milliseconds (default 5000)
 * @returns the endpoints schema or empty object if unavailable
 */
async function fetchServerSchema(
  serverUrl: string,
  timeoutMs = 5000,
): Promise<PluginEndpoints> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    console.log(`[AppKit] Fetching schema from ${serverUrl}/__schema__`);
    const response = await fetch(`${serverUrl}/__schema__`, {
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      console.warn(
        `[AppKit] Could not fetch schema from ${serverUrl}/__schema__ (${response.status})`,
      );
      return {};
    }
    const data = (await response.json()) as { endpoints?: PluginEndpoints };
    console.log(`[AppKit] Schema fetched successfully`);
    return data.endpoints || {};
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === "AbortError") {
      console.warn(`[AppKit] Timeout fetching schema from ${serverUrl}`);
    } else {
      console.warn(
        `[AppKit] Could not connect to server at ${serverUrl}:`,
        error instanceof Error ? error.message : error,
      );
    }
    return {};
  }
}

/**
 * Entry point for generating type declarations from all imported files
 * @param options - the options for the generation
 * @param options.entryPoint - the entry point file
 * @param options.outFile - the output file
 * @param options.querySchemaFile - optional path to query schema file (e.g. config/queries/schema.ts)
 * @param options.serverUrl - optional server URL to fetch plugin endpoints from
 */
export async function generateFromEntryPoint(options: {
  outFile: string;
  queryFolder?: string;
  warehouseId: string;
  noCache?: boolean;
  serverUrl?: string;
}) {
  const { outFile, queryFolder, warehouseId, noCache, serverUrl } = options;

  console.log("\n[AppKit] Starting type generation...\n");

  let queryRegistry: QuerySchema[] = [];

  if (queryFolder)
    queryRegistry = await generateQueriesFromDescribe(
      queryFolder,
      warehouseId,
      {
        noCache,
      },
    );

  // Fetch plugin endpoints from server if URL provided
  let endpoints: PluginEndpoints = {};
  if (serverUrl) {
    console.log(`[AppKit] Fetching plugin schema from ${serverUrl}...`);

    endpoints = await fetchServerSchema(serverUrl);
    const pluginCount = Object.keys(endpoints).length;
    console.log(`[AppKit] Found ${pluginCount} plugins with endpoints`);
  }

  const typeDeclarations = generateTypeDeclarations(queryRegistry, endpoints);

  fs.writeFileSync(outFile, typeDeclarations, "utf-8");

  console.log("\n[AppKit] Type generation complete!\n");
}
