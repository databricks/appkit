import fs from "node:fs";
import path from "node:path";
import type { QuerySchemas } from "shared";
import { createAuxiliaryTypeStore, printNode, zodToTs } from "zod-to-ts";
import { type Plugin, routeSchemaRegistry } from "@/plugin";

interface AppKitRegistry {
  pluginRegistry: string;
  queryRegistry: string;
}

const TYPE_FILE_NAME = "appKitTypes.d.ts";
const DEFAULT_TYPE_PATH = path.join(process.cwd(), "client", "src");

let writeLock: Promise<void> = Promise.resolve();

function indentType(typeString: string, baseIndent: string): string {
  const lines = typeString.split("\n");
  if (lines.length === 1) return typeString;

  return lines
    .map((line, index) => (index === 0 ? line : baseIndent + line))
    .join("\n");
}

function resolveTypePath(typePath?: string): string {
  if (!typePath) return DEFAULT_TYPE_PATH;
  if (typePath.endsWith("dist")) {
    return typePath.replace(/dist$/, "src");
  }
  return typePath;
}

function readExistingTypes(filePath: string): AppKitRegistry {
  if (!fs.existsSync(filePath)) {
    return { pluginRegistry: "", queryRegistry: "" };
  }

  const content = fs.readFileSync(filePath, "utf-8");

  const pluginMatch = content.match(
    /interface PluginRegistry \{([\s\S]*?)\n {2}\}/,
  );
  const queryMatch = content.match(
    /interface QueryRegistry \{([\s\S]*?)\n {2}\}/,
  );

  return {
    pluginRegistry: pluginMatch?.[1] ?? "",
    queryRegistry: queryMatch?.[1] ?? "",
  };
}

function withLock<T>(fn: () => T | Promise<T>): Promise<T> {
  const execute = async (): Promise<T> => {
    await writeLock;
    return fn();
  };

  const newLock = execute();
  writeLock = newLock.then(
    () => {},
    () => {},
  );
  return newLock;
}

function writeTypeFile(
  filePath: string,
  pluginRegistry: string,
  queryRegistry: string,
) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    console.log(
      `[AppKit] Type path not found: ${dir}, skipping type generation`,
    );
    return;
  }

  const querySection = queryRegistry
    ? `\n  interface QueryRegistry {\n${queryRegistry}\n  }`
    : "";

  const content = `// Auto-generated by AppKit - DO NOT EDIT
import "@databricks/app-kit-ui/react";

declare module "@databricks/app-kit-ui/react" {
  interface PluginRegistry {
${pluginRegistry}
  }
${querySection}
}
`;

  fs.writeFileSync(filePath, content, "utf-8");
  console.log(`[AppKit] Types generated: ${filePath}`);
}

// generate plugin registry types for development
export function generatePluginRegistryTypes(
  plugins: Record<string, Plugin> | undefined,
  typePath?: string,
) {
  if (!plugins) return;

  withLock(() => {
    const resolvedPath = resolveTypePath(typePath);
    const filePath = path.join(resolvedPath, TYPE_FILE_NAME);
    const existing = readExistingTypes(filePath);
    const auxiliaryTypeStore = createAuxiliaryTypeStore();

    const pluginTypes = Object.entries(plugins)
      .map(([name]) => {
        const routes = routeSchemaRegistry.get(name);
        if (!routes || routes.size === 0) return null;

        const routeTypes = Array.from(routes.entries())
          .map(([route, schema]) => {
            const { node } = zodToTs(schema, { auxiliaryTypeStore });
            const typeString = printNode(node);
            return `      "${route}": ${indentType(typeString, "      ")};`;
          })
          .join("\n");
        return `    "${name}": {\n${routeTypes}\n    }`;
      })
      .filter(Boolean)
      .join("\n");

    writeTypeFile(filePath, pluginTypes, existing.queryRegistry);
  });
}

export function generateQueryRegistryTypes(
  querySchemas: QuerySchemas,
  typePath?: string,
) {
  withLock(() => {
    const resolvedPath = resolveTypePath(typePath);
    const filePath = path.join(resolvedPath, TYPE_FILE_NAME);
    const existing = readExistingTypes(filePath);
    const auxiliaryTypeStore = createAuxiliaryTypeStore();

    let queryTypes = "";
    if (querySchemas && Object.keys(querySchemas).length > 0) {
      queryTypes = Object.entries(querySchemas)
        .map(([queryKey, schema]) => {
          const { node } = zodToTs(schema, { auxiliaryTypeStore });
          const typeString = printNode(node);
          return `    ${queryKey}: ${indentType(typeString, "    ")};`;
        })
        .join("\n");
    }

    writeTypeFile(filePath, existing.pluginRegistry, queryTypes);
  });
}
